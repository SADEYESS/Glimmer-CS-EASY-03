### 一、C语言内存模型
| 内存分区                  | 具体含义   |应用场景    |调用方式|
| -                        | -         |-           |-       |
| 程序代码区 (code)         |存储源代码被编译后生成的的机器指令的内存区域|当程序被调进内存中运行时,系统会调用其中的内容|程序运行时系统自动调用|
| 常量区 (constant)         |存储程序中的常量数据的内存区域|存储程序在编写时定义的常量,如字符串常量,使用 const 指令定义的常量以及使用 #define 宏定义的常量|程序运行需要调用到相应常量时系统自动调用|
| 全局数据区 (global data)  |存储程序中的全局变量和静态变量之类的生命周期贯穿整个程序的变量的内存区域|存储程序在编写时定义的全局变量和静态变量,如在函数外使用 int 和 static 声明的变量|程序运行需要调用到相应全局变量或静态变量时系统自动调用|
| 堆区 (heap)               |存储程序运行时需要被动态分配的内存的区域|需要动态分配内存时,如链表和动态数组|通过 malloc 等函数在程序中调用|
| 动态链接库                |存储动态链接库文件的内存区域，动态链接库是一种可以在运行时让多个程序共享相同的代码的共享库文件|程序运行需要调用库文件中的函数内容时|程序运行需要调用到库文件中的代码时系统自动调用|
| 栈区 (stack)             |存储程序中的函数调用信息、局部变量、函数参数和返回地址等生命周期较短的内容的内存区域|存储程序中的局部变量，如在某个函数内声明的 int 变量,函数在定义时使用的形式参数,函数的返回值等|程序运行需要调用到相应变量时系统自动调用|

&nbsp;
#### **Q1:什么是“栈溢出”？**
“栈溢出”是指程序在使用的栈区内存时超出了被允许被调用的最大容量，导致无法继续调用内存，会导致程序崩溃或出现难以预料的错误
&nbsp;
#### **Q2:堆区和栈区的区别是什么？**
- 堆区的内存被动态分配，需要手动调用
- 栈区的内存存储程序中局部变量等的内存，由系统自动调用
&nbsp;
#### **Q3:程序运行过程中，内存模型当中的哪些区是只读的，哪些区是可读写的？**
- 只读：程序代码区、常量区、动态链接库内的代码部分
- 可读写：全局数据区、堆区、动态链接库内的数据部分、栈区
&nbsp;
#### **Q4:如何使用malloc()、free()函数，它们针对的哪一个区进行操作？**
1. - malloc()、free()都是包含在 stdlib.h 头文件里的函数，要调用这两个函数首先需要调用 stdlib.h 头文件
   - malloc()函数的原型为 `void* malloc(size_t size)`
因此要写出变量名以及需要申请分配的字节数，举例对于 `int* p` 可以通过 `p = malloc(sizeof(int))` 来为整型指针p来申请大小为 `sizeof(int)` 的内存空间
   - free()函数的原型为 `void free(void *ptr)`
因此只要写出要释放的变量名，如 `free(p)`
&nbsp;
1. - 它们针对堆区进行操作
&nbsp;
#### **Q5:为什么要对程序使用的内存进行管理？**
- 对程序使用的内存进行管理能够减少因为缺少管理造成的内存溢出，降低程序运行出错或崩溃的风险，有助于程序运行的稳定
- 对程序使用的内存进行管理有助于程序员合理安排程序的内存占用，提高程序的运行效率


&nbsp;
### 二、内存模型的应用
```C
#include <stdio.h>
#include <stdlib.h>

const int constValue = 100;
const char* constString = "Hello, World!";
int globalVar = 10;

void function(int arg) {
    int localVar = 20;
    int *ptr = malloc(sizeof(int));
    *ptr = 30;
    free(ptr);
}

int main() {
    static int staticVar = 40;
    int localVarMain = 50;
    function(60);
    return 0;
}
```
`constValue` 和 `constString` 存储在常量区。在小强的程序中这些变量是在函数外定义的，也就意味着这些变量在程序全局都可以使用，且这些数据在使用时是以只读模式访问，无法被更改。如果这种变量存储在其他区域，该变量可能并不能全局都能被调用，还有可能遭到意外的更改，导致程序出错

`globalVar` 和 `staticVar`存储在全局数据区。`globalVar`是小强在函数外部声明的，`staticVar`虽然是小强在 main 函数内部声明的，但这是一个 `static int` 类型的静态整型变量，因此两个变量的生命周期都与程序的整个生命周期相同，在全局都可以被调用，而且可以改变变量值。如果存储在其他位置，这种类型的变量可能无法在全局使用或变量的值无法随时更改

`localVar` 和 `localVarMain`存储在栈区，这两个变量分别是在 `function` 函数和 `main` 函数中定义的，这两个变量只在各自的函数中被使用，函数运行结束后其所占用的空间也被释放。如果存储在栈区以外的区域，这两个变量占用的可能无法及时得到释放，若这种变量的数目过多，程序面临的内存溢出的风险会加大

`ptr`存储在堆区。在小强的程序中，`ptr` 是一个指向整型数值的指针变量，并且采用了 `malloc` 函数来为 ptr 动态分配内存空间，后面采用了 `free` 函数来释放 `ptr` 占用的内存空间。如果 ptr 不在堆区，这个变量的内存占用会由系统进行管理，相应的函数操作也无法使用


&nbsp;
### 三、浅谈Cache
#### **Q1:什么是冯诺伊曼体系结构？什么是现代计算机的组织结构？这两者的不同点在哪里？**、
1. 冯诺伊曼体系结构是冯·诺伊曼提出的一种计算机体系结构模型。这个结构将程序指令存储器和数据存储器合并在一起，是单一存储器的结构。计算机通过运算器和控制器组成的中央处理器依次读取、解码和执行存储器中的指令。在这个结构的定义下，计算机系统主要由运算器、控制器、存储器、输入设备、输出设备五个部分组成
2. 现代计算机主要由中央处理器、存储系统、输入设备、输出设备、总线系统、软件等部分组成，各个部分之间的的工作协同更加密切
3. - 冯诺伊曼体系结构计算机以运算器为中心，输入设备、输出设备已经存储器之间的数据通过运算器来完成；现代计算机以CPU为中心，CPU内部集成了运算器和控制器
   - 冯诺伊曼体系结构采用单一存储器结构，将数据和程序指令存储在同一个存储器中；现代计算机通常采用多级存储系统
   - 冯诺伊曼体系在执行指令时按照结构顺序执行，以单线程方式处理任务，不能同时执行多个任务；现代计算机支持多核和多线程处理，能够同时执行多个任务
&nbsp;
#### **Q2:主存储器是如何工作的？**
- 当主存储器要输出内容时：
1. CPU通过地址总线将目标数据的地址发送给主存储器
2. 主存储器接收并解析CPU发送的地址，确定要访问的存储单元
3. 主存储器将CPU需求的的的数据读取到数据寄存器中
4. CPU从数据寄存器中读取数据，通过数据总线完成读取
&nbsp;
- 当主存储器要存入内容时：
1. CPU通过地址总线将目标地址发送给主存储器
2. CPU准备好要写入主存储器的数据，并发送到数据寄存器中
3. 主存储器根据接收到的地址，将数据寄存器中的数据写入到对应的存储单元中
&nbsp;
#### **Q3:什么是Cache的局部性原理？它包括哪些方面的内容？**
Cache即缓存，Cache的局部性原理是指程序在访问数据时，通常表现出某些特定的规律性，使Cache可以有效地存储和提供运行程序的过程中经常使用的数据，从而提高系统的性能。Cache的局部性原理包括时间局部性和空间局部性。
- Cache的**时间局部性**是指Cache中会保留最近使用的数据项，以便后续再次访问时能更快地获取该数据
- Cache的**空间局部性**是指Cache在加载一个数据项时，会同时加载与其物理存储位置邻近的的多个数据项
&nbsp;
#### **Q4:Cache的运用为什么可以加快系统整体性能？**
- Cache通过利用其局部性原理保存一定的数据，减少了计算机从主存储器中进行读取的次数，使程序运行中频繁使用的数据或指令可以在短时间内再次被访问
- Cache的物理位置在CPU内部或非常接近CPU，其性能很强，访问速度远快于主存储器
- 当Cache中的内容有效时，CPU不需要频繁访问运行速度相对较慢的存储设备，从而减少了输入/输出操作的瓶颈
- 现代CPU通常有多级Cache，不同层次的Cache用于存储不同大小和频率的数据。多级缓存结构允许CPU同时处理不同类型的数据请求，处理效率更高
&nbsp;
### 四、代码优化
回顾最近写过的代码，下面是我在基础题第一题（CS-EASY-01）完成的课后题（求两数的最大公约数），经过到目前的学习，这个程序可以做进一步的优化
&nbsp;
原代码如下：
```c
#include <stdio.h>

int main()
{
    int m,n,GCD;   //声明需要输入的两个变量m，n，由于0<m,n<2^31,可以用int类型表示
                   //声明一个变量GCD作为最大公约数(Greatest Common Divisor)来进行后面的运算
    while(1)       //使用 while 循环验证用户的输入是否满足要求
    {
    printf("Please enter two positive integers:\n");  //提示用户输入两个正整数
    scanf("%d %d",&m,&n); //读取用户输入
        if (m > 0 && m < 2147483648 && n > 0 && n < 2147483648) //m，n要同时满足>0且<2^31
        {
            break; //满足条件则跳出循环，进入下一步的运算
        }
        else
        {
            printf("Wrong numbers,try again\n");  //不满足条件则提示用户重新输入，再次进入循环
        }
    }

    for(GCD=(m<n?m:n);GCD>=1;GCD--) //将GCD初始化为用户输入的两数中较小的一个
    {                               //利用 for循环 逐个验证，当某数可以同时被两数整除时，该数字则为两数的最大公约数
        if(m % GCD==0 && n % GCD==0)
        {
            printf("The greatest common divisor is %d",GCD);  //打印出求得的最大公约数
            return 0;
        }
    }
return 0;
}
```
&nbsp;
如果输入的两数很大，按照 for 循环的穷举法需要尝试的次数可能会过多，造成栈溢出
&nbsp;
现在修改过后的代码如下：
```c
#include <stdio.h>

int GetGCD(int m, int n)   //建立新函数，使用更加简洁的欧几里得法求最大共同公约数，两个数的最大公约数等于较小数与较大数的余数的最大公约数
{
    while (m != 0)         //不断进行循环，直到作为余数的 m 的值为 0
    {
        int helper;
        helper = m;        //先借助一个变量保存其中一个数 m 的值
        m = n % m;         //把 n 除以 m 的余数赋给 m
        n = helper;        //把 m 的原始值赋给新的 n
    }
return n;                  //返回作为最大公约数的 n
}

int main() 
{
    int m, n;
    
    while (1) 
    {
        printf("Please enter two positive integers:\n");

        if (scanf("%d %d", &m, &n) == 2 && m > 0 && m < 2147483647 && n >= 0 && n < 2147483647)   //利用 scanf 函数储存在栈区的返回值判断两数是否读取成功
        { 
            break;
        } 
        else 
        {
            printf("Wrong numbers, try again\n");
            while (getchar() != '\n');           //使用 getchar 清除存储在输入缓冲区的内容，防止出错
        }
    }
    printf("The greatest common divisor is %d\n", GetGCD(m, n));

return 0;
}
```
&nbsp;
原程序在运行时需要从较小的数字开始依次向下递减做尝试，使用欧几里得法求最大公约数采用除法运算可以有效利用缓存中的数据，运算次数的明显减少也使得栈溢出的风险减低
&nbsp;
![](https://s3.bmp.ovh/imgs/2024/10/13/cff331611961e153.png)
如图所示，在输入较大的数字时，采用欧几里得法（gcdadvanced）求最大公约数的时间要明显快于穷举法（gcd）


&nbsp;
### 五、写在最后
在学习本节内容之前，我对“内存”和“缓存”之类词语并不陌生，但经过本章的学习，我才真正理解了这些部分的工作原理。在真实的程序设计过程中，程序员不仅要实现程序的功能，还要关注代码的运行效率，在不断的优化中使程序更加完善。计算机系统是一个复杂且精密的结构，各部分之间的联系错综复杂，每个部分的高效运行都需要精细的管理和优化，我对计算机硬件结构原理的了解刚刚起步，因此今后的学习中，我需要了解的内容还有很多
